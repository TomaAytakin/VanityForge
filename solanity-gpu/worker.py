import argparse
import subprocess
import json
import os
import glob
import sys
import base58

def main():
    parser = argparse.ArgumentParser(description="Solana CPU Vanity Address Worker")
    parser.add_argument("--prefix", help="Prefix to search for", default="")
    parser.add_argument("--suffix", help="Suffix to search for", default="")
    # Allow mapping from old args if necessary, or just rely on these being passed
    # The prompt specifically says "Args: Parse --prefix (map to --starts-with) and --suffix (map to --ends-with)."
    # solana-keygen grind uses --starts-with and --ends-with

    args = parser.parse_args()

    # Determine command arguments for solana-keygen grind
    grind_args = []
    if args.prefix:
        grind_args.append(f"--starts-with")
        grind_args.append(f"{args.prefix}:1") # :1 means find 1 match
    elif args.suffix:
        grind_args.append(f"--ends-with")
        grind_args.append(f"{args.suffix}:1")
    else:
        # If neither, maybe exit or log? The worker assumes valid input.
        # But for safety:
        print(json.dumps({"found": False, "error": "No prefix or suffix provided"}))
        sys.exit(1)

    command = ["solana-keygen", "grind"] + grind_args

    # We want to run this in the current directory so we can find the output file
    try:
        # Run solana-keygen grind
        # It prints "Wrote keypair to ..." to stdout
        process = subprocess.run(command, check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)

        # Identify the file from the output or by scanning directory
        # solana-keygen grind outputs filenames usually as <INPUT>XXXX.json
        # Easier to scan for .json files created recently or just all json files if we assume clean container
        # The container is clean.

        json_files = glob.glob("*.json")
        found_file = None

        # Filter for the expected file pattern if needed, but in a fresh container/workdir,
        # the only json file should be the one we just created (unless there are others).
        # We know the input was prefix or suffix.

        for f in json_files:
            # We expect a file that contains the keypair.
            # solana-keygen output: "Wrote keypair to <filename>.json"
            # We can parse stdout if we want to be precise.
            if f in process.stdout:
                found_file = f
                break

        if not found_file and json_files:
            # Fallback: take the first json file found that looks like a keypair
            found_file = json_files[0]

        if found_file:
            with open(found_file, "r") as f:
                keypair_data = json.load(f)

            # keypair_data is a list of integers (byte array)
            # Convert to bytes
            private_key_bytes = bytes(keypair_data)

            # Convert to Base58 string
            private_key_b58 = base58.b58encode(private_key_bytes).decode('utf-8')

            # Public Key calculation
            # We can derive it or solana-keygen output it.
            # Actually, the filename usually is the public key if generated by `solana-keygen new`,
            # but `grind` names it based on the pattern usually?
            # Wait, `solana-keygen grind` filenames are usually `prefix.....json`.
            # To get the public key reliably, we can re-derive it or just use `solana-keygen pubkey` on the file.
            # But we have the keypair bytes. The first 32 bytes are the private scalar, the last 32 are the public key.
            # Solana keypair format: 64 bytes. First 32 is seed, last 32 is pubkey.

            # Let's verify this assumption.
            # standard solana keypair file is just the 64 bytes.
            if len(keypair_data) == 64:
                 public_key_bytes = private_key_bytes[32:]
                 public_key_b58 = base58.b58encode(public_key_bytes).decode('utf-8')
            else:
                # If something is weird, we can run `solana-keygen pubkey found_file`
                pub_process = subprocess.run(["solana-keygen", "pubkey", found_file], capture_output=True, text=True)
                public_key_b58 = pub_process.stdout.strip()

            print(json.dumps({
                "found": True,
                "public_key": public_key_b58,
                "private_key": private_key_b58
            }))

            # Cleanup
            os.remove(found_file)

        else:
             print(json.dumps({"found": False, "error": "No keypair file found"}))

    except subprocess.CalledProcessError as e:
        print(json.dumps({"found": False, "error": str(e), "stderr": e.stderr}))
        sys.exit(1)
    except Exception as e:
        print(json.dumps({"found": False, "error": str(e)}))
        sys.exit(1)

if __name__ == "__main__":
    main()

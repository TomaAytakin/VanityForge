# Phase 1: High-Throughput ECC Iterator (Scalar+Point Add) Implementation Notes

## Architectural Pivot
This update implements the "Two-Phase" architecture with ECC in Phase 1 to allow direct Point Addition, avoiding SHA-512 overhead entirely in the hot loop.

### Phase 1 (Implemented)
- **Role:** Scalar Iterator + Binary Prefix Filter.
- **Goal:** Iterate Public Keys (P' = P + B) and filter based on binary prefix of Affine coordinates.
- **Kernel:** `phase1_filter_kernel`
- **Optimization:**
  - **Batch Inversion:** Amortizes `fe_invert` cost (4 keys per invert).
  - **Incremental Stepping:** `P += B` using `ge_madd` (fast mixed addition).
  - **Shared Memory:** Stores Batch data to keep register usage < 64.
- **Throughput Target:** > 300 MH/s on L4.

### Phase 2 (Implemented on Host)
- **Role:** Full Solver.
- **Goal:** Consume candidates from Ring Buffer, reconstruct Scalar, verify, and check Suffix.
- **Implementation:** Host-side C++ loop using `ge_scalarmult_base`.

### Register Usage Analysis
- **Constraint:** < 64 registers per thread.
- **Strategy:** Move large arrays (Batch Z/Y) to Shared Memory. Use `__launch_bounds__`.
- **Spills:** 0 expected.
